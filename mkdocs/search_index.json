{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\u00b6\n\n\nExtensible Virtual Display Interface (EVDI in short) is a software project that allows any userspace Linux program manage additional displays, and receive updates for them.\nThis short document explains how to use EVDI library in your application.\n\n\nFor more details about EVDI project and the latest code, see the \nproject page\n on DisplayLink's GitHub.\n\n\nProject origin\n\u00b6\n\n\nEVDI is a project that was started by DisplayLink as a base for the development of DisplayLink's Display driver for Ubuntu Linux, driving all\ncurrent generation, USB 3.0 Universal Docking Stations and USB Display Adapters.\n\n\nHowever, it soon became apparent that we're making a generic interface that any other application could use - and that's when DisplayLink decided to open-source the code and push it to GitHub.\n\n\n\n\nInfo\n\n\nThe interface of the library is still changing. Please treat the API as not yet stable - in terms of allowing the possibility that\nit can still be modified, and your clients may require matching updates.",
            "title": "Home"
        },
        {
            "location": "/#introduction",
            "text": "Extensible Virtual Display Interface (EVDI in short) is a software project that allows any userspace Linux program manage additional displays, and receive updates for them.\nThis short document explains how to use EVDI library in your application.  For more details about EVDI project and the latest code, see the  project page  on DisplayLink's GitHub.",
            "title": "Introduction"
        },
        {
            "location": "/#project-origin",
            "text": "EVDI is a project that was started by DisplayLink as a base for the development of DisplayLink's Display driver for Ubuntu Linux, driving all\ncurrent generation, USB 3.0 Universal Docking Stations and USB Display Adapters.  However, it soon became apparent that we're making a generic interface that any other application could use - and that's when DisplayLink decided to open-source the code and push it to GitHub.   Info  The interface of the library is still changing. Please treat the API as not yet stable - in terms of allowing the possibility that\nit can still be modified, and your clients may require matching updates.",
            "title": "Project origin"
        },
        {
            "location": "/quickstart/",
            "text": "Quick Start\n\n\nTypical application\n\n\nEVDI nodes\n\n\nAdding new nodes\n\n\nOpening and closing EVDI node\n\n\n\n\n\n\nConnecting and disconnecting\n\n\nFrame buffers\n\n\nCursor\n\n\nRunning loop\n\n\nEvents and notifications\n\n\nTypes of events\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuick Start\n\u00b6\n\n\nThis section explains how to write a basic client for EVDI. Details of API calls are ommitted here for brevity.\n\n\nTypical application\n\u00b6\n\n\nApplications using EVDI will typically:\n\n\n\n\nfind a free EVDI node, or add a new node if none was found; then open it\n\n\nconnect to the EVDI node, letting the DRM subsystem know what is the monitor that the application drives\n\n\nallocate memory for, and register buffer(s) that will be used to receive screen updates\n\n\nrequest and consume updates and other notifications in a loop\n\n\n\n\nEVDI nodes\n\u00b6\n\n\nEVDI reuses DRM subsystem's \ncardX\n nodes for passing messages between the kernel and userspace.\nIn order to distinguish non-EVDI nodes from a node that's created by EVDI kernel module, \nevdi_check_device\n function should be used.\n\n\nThe library only allows to connect to DRM nodes that are created by EVDI.\nAttempts to connect to other nodes (e.g. related to a built-in GPU) will fail.\n\n\n\n\nNote\n\n\nUsing EVDI nodes currently requires administrative rights, so applications must be run with \nsudo\n, or by root.\n\n\n\n\nAdding new nodes\n\u00b6\n\n\nIn order to create a new EVDI \ncardX\n node, call \nevdi_add_device\n function.\nA single call adds one additional DRM card node that can later be used to connect to.\n\n\nAt the moment, every extra screen that you want to manage needs a separate node.\n\n\nOpening and closing EVDI node\n\u00b6\n\n\nOnce an available EVDI node is identified, your application should call \nevdi_open\n, passing a number of \ncardX\n that you want to open.\nThis returns an \nevdi_handle\n that you will use for following API calls, or \nEVDI_INVALID_HANDLE\n if opening failed.\n\n\nIn order to close the handle, call \nevdi_close\n.\n\n\nConnecting and disconnecting\n\u00b6\n\n\nConnecting to EVDI tells DRM subsystem that there is a monitor connected, and from this moment the system is aware of an extra display.\nConnection also lets DRM know what is the \nEDID\n of the monitor that a particular EVDI node handles.\nThink of this as something similar to plugging a monitor with a cable to a port of a graphics card.\n\n\nSimilarly, disconnecting indicates that the display is no longer there - like physically pulling cable out from the graphics adapter port.\n\n\nTo connect or disconnect, use \nevdi_connect\n and \nevdi_disconnect\n, respectively.\n\n\nFrame buffers\n\u00b6\n\n\nTo know what the contents of the screen is, your application will use a block of memory that it can read pixel data from.\n\n\nThe library itself does \nnot\n allocate any memory for buffers - this is to allow more control in the client application.\nTherefore, before you request screen updates for the screens you're managing, an appropriate amount of memory must be allocated to hold screen data within your application.\nThe application can register as many buffers as you like, and subsequent update requests can refer to any buffer that was previously registered.\n\n\nAllocated memory is made available for EVDI library to use by calling \nevdi_register_buffer\n. Symetrically, \nevdi_unregister_buffer\n is used to tell the library not to use the buffer anymore.\n\n\nCursor\n\u00b6\n\n\nMouse cursor is an important part of the desktop. Because of this, evdi provides special control over it.\n\n\nThere are two ways to handle cursor:\n\n\n\n\nAutomatic cursor compositing on framebuffer(default). Every cursor change causes \nupdate_ready\n event to be raised. In the following grab pixels operation evdi will compose cursor\non the user supplied framebuffer. This option is enabled by \nenable_cursor_blending\n module parameter.\n\n\nCursor change notifications. Enabled when \nenable_cursor_blending\n is set to N(no).\nIn that mode the responsibility for cursor blending is passed to the library client. Instead of \nupdate_ready\n event the \ncursor_set\n and \ncursor_move\n notifications are sent.\n\n\n\n\nRunning loop\n\u00b6\n\n\nAfter registering buffers, the application should start requesting updates for them. This is done using \nevdi_request_update\n.\nYou should call it when you intend to consume pixels for the screen.\n\n\nOnce the request to update buffer is handled by the kernel module, you can use \nevdi_grab_pixels\n to get the data in your app.\nThis also includes finding out which areas of the buffer are in fact modified, compared to a previous update.\n\n\nEvents and notifications\n\u00b6\n\n\nDue to its design and split of responsibilities between the kernel and userspace code, EVDI's working model is an asynchronous.\nTherefore, your application should monitor a file descriptor exposed by \nevdi_get_event_ready\n function, and once it becomes ready to read,\ncall \nevdi_handle_events\n to dispatch events that are being signalled to the right handlers.\n\n\nThe handlers are defined in your application and are shared with the library through a \nevdi_event_context\n structure that \nevdi_handle_events\n uses for dispatching the call.\n\n\nTypes of events\n\u00b6\n\n\nThe notifications your application can (and should) be handling, are:\n\n\n\n\nUpdate ready notification (sent once a request to update a buffer is handled by kernel)\n\n\nMode changed notification (sent from DRM after screen mode is changed)\n\n\nDPMS notifications (telling the new power state of a connector)\n\n\nCRTC state change event (exposing DRM CRTC state)\n\n\nCursor events (send when cursor position or state changes)\n\n\n\n\nYou will start receiving first notifications from the kernel module right after connecting to EVDI.\nYour application should use this information before you ask for screen updates to make sure the buffers are the right size.",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#quick-start",
            "text": "This section explains how to write a basic client for EVDI. Details of API calls are ommitted here for brevity.",
            "title": "Quick Start"
        },
        {
            "location": "/quickstart/#typical-application",
            "text": "Applications using EVDI will typically:   find a free EVDI node, or add a new node if none was found; then open it  connect to the EVDI node, letting the DRM subsystem know what is the monitor that the application drives  allocate memory for, and register buffer(s) that will be used to receive screen updates  request and consume updates and other notifications in a loop",
            "title": "Typical application"
        },
        {
            "location": "/quickstart/#evdi-nodes",
            "text": "EVDI reuses DRM subsystem's  cardX  nodes for passing messages between the kernel and userspace.\nIn order to distinguish non-EVDI nodes from a node that's created by EVDI kernel module,  evdi_check_device  function should be used.  The library only allows to connect to DRM nodes that are created by EVDI.\nAttempts to connect to other nodes (e.g. related to a built-in GPU) will fail.   Note  Using EVDI nodes currently requires administrative rights, so applications must be run with  sudo , or by root.",
            "title": "EVDI nodes"
        },
        {
            "location": "/quickstart/#adding-new-nodes",
            "text": "In order to create a new EVDI  cardX  node, call  evdi_add_device  function.\nA single call adds one additional DRM card node that can later be used to connect to.  At the moment, every extra screen that you want to manage needs a separate node.",
            "title": "Adding new nodes"
        },
        {
            "location": "/quickstart/#opening-and-closing-evdi-node",
            "text": "Once an available EVDI node is identified, your application should call  evdi_open , passing a number of  cardX  that you want to open.\nThis returns an  evdi_handle  that you will use for following API calls, or  EVDI_INVALID_HANDLE  if opening failed.  In order to close the handle, call  evdi_close .",
            "title": "Opening and closing EVDI node"
        },
        {
            "location": "/quickstart/#connecting-and-disconnecting",
            "text": "Connecting to EVDI tells DRM subsystem that there is a monitor connected, and from this moment the system is aware of an extra display.\nConnection also lets DRM know what is the  EDID  of the monitor that a particular EVDI node handles.\nThink of this as something similar to plugging a monitor with a cable to a port of a graphics card.  Similarly, disconnecting indicates that the display is no longer there - like physically pulling cable out from the graphics adapter port.  To connect or disconnect, use  evdi_connect  and  evdi_disconnect , respectively.",
            "title": "Connecting and disconnecting"
        },
        {
            "location": "/quickstart/#frame-buffers",
            "text": "To know what the contents of the screen is, your application will use a block of memory that it can read pixel data from.  The library itself does  not  allocate any memory for buffers - this is to allow more control in the client application.\nTherefore, before you request screen updates for the screens you're managing, an appropriate amount of memory must be allocated to hold screen data within your application.\nThe application can register as many buffers as you like, and subsequent update requests can refer to any buffer that was previously registered.  Allocated memory is made available for EVDI library to use by calling  evdi_register_buffer . Symetrically,  evdi_unregister_buffer  is used to tell the library not to use the buffer anymore.",
            "title": "Frame buffers"
        },
        {
            "location": "/quickstart/#cursor",
            "text": "Mouse cursor is an important part of the desktop. Because of this, evdi provides special control over it.  There are two ways to handle cursor:   Automatic cursor compositing on framebuffer(default). Every cursor change causes  update_ready  event to be raised. In the following grab pixels operation evdi will compose cursor\non the user supplied framebuffer. This option is enabled by  enable_cursor_blending  module parameter.  Cursor change notifications. Enabled when  enable_cursor_blending  is set to N(no).\nIn that mode the responsibility for cursor blending is passed to the library client. Instead of  update_ready  event the  cursor_set  and  cursor_move  notifications are sent.",
            "title": "Cursor"
        },
        {
            "location": "/quickstart/#running-loop",
            "text": "After registering buffers, the application should start requesting updates for them. This is done using  evdi_request_update .\nYou should call it when you intend to consume pixels for the screen.  Once the request to update buffer is handled by the kernel module, you can use  evdi_grab_pixels  to get the data in your app.\nThis also includes finding out which areas of the buffer are in fact modified, compared to a previous update.",
            "title": "Running loop"
        },
        {
            "location": "/quickstart/#events-and-notifications",
            "text": "Due to its design and split of responsibilities between the kernel and userspace code, EVDI's working model is an asynchronous.\nTherefore, your application should monitor a file descriptor exposed by  evdi_get_event_ready  function, and once it becomes ready to read,\ncall  evdi_handle_events  to dispatch events that are being signalled to the right handlers.  The handlers are defined in your application and are shared with the library through a  evdi_event_context  structure that  evdi_handle_events  uses for dispatching the call.",
            "title": "Events and notifications"
        },
        {
            "location": "/quickstart/#types-of-events",
            "text": "The notifications your application can (and should) be handling, are:   Update ready notification (sent once a request to update a buffer is handled by kernel)  Mode changed notification (sent from DRM after screen mode is changed)  DPMS notifications (telling the new power state of a connector)  CRTC state change event (exposing DRM CRTC state)  Cursor events (send when cursor position or state changes)   You will start receiving first notifications from the kernel module right after connecting to EVDI.\nYour application should use this information before you ask for screen updates to make sure the buffers are the right size.",
            "title": "Types of events"
        },
        {
            "location": "/details/",
            "text": "API Details\n\n\nFunctions by group\n\n\nVersioning\n\n\nModule parameters\n\n\nEVDI nodes\n\n\nFinding an available EVDI node to use\n\n\nAdding new EVDI node\n\n\nOpening device nodes\n\n\nClosing devices\n\n\n\n\n\n\nConnection\n\n\nOpening connections\n\n\nDisconnecting\n\n\n\n\n\n\nBuffers\n\n\nRegistering\n\n\nUnregistering\n\n\n\n\n\n\nScreen updates\n\n\nRequesting an update\n\n\nGrabbing pixels\n\n\n\n\n\n\nEvents and handlers\n\n\nDPMS mode change\n\n\nMode change notification\n\n\nUpdate ready notification\n\n\nCursor change notification\n\n\nCursor move notification\n\n\nCRTC state change\n\n\n\n\n\n\n\n\n\n\nTypes\n\n\nevdi_handle\n\n\nevdi_selectable\n\n\nevdi_device_status\n\n\nevdi_rect\n\n\nevdi_mode\n\n\nevdi_buffer\n\n\nevdi_event_context\n\n\nevdi_lib_version\n\n\nevdi_cursor_set\n\n\nevdi_cursor_move\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAPI Details\n\u00b6\n\n\nFunctions by group\n\u00b6\n\n\nVersioning\n\u00b6\n\n\n1\nevdi_get_lib_version\n(\nstruct\n \nevdi_lib_version\n \ndevice\n);\n\n\n\n\n\n\n\nFunction returns library version. \nIt uses semantic versioning to mark compatibility changes.\nVersion consists of 3 components formatted as MAJOR.MINOR.PATCH\n\n\n\n\nMAJOR\n number is changed for incompatibile API changes\n\n\nMINOR\n number is changed for backwards-compatible changes\n\n\nPATCH\n number is changed for backwards-compatibile bug fixes\n\n\n\n\nModule parameters\n\u00b6\n\n\nUser can modify driver behaviour by its parameters that can be set at module load time or changed during runtime.\n\n\n\n\nenable_cursor_blending\n Enables cursor compositing on user supplied framebuffer via \nEVDI_GRABPIX\n ioctl (default: true)\n\n\n\n\nEVDI nodes\n\u00b6\n\n\nFinding an available EVDI node to use\n\u00b6\n\n\n1\nevdi_device_status\n \nevdi_check_device\n(\nint\n \ndevice\n);\n\n\n\n\n\n\n\nUse this function to check if a particular \n/dev/dri/cardX\n is EVDI or not.\n\n\nArguments:\n \ndevice\n is a number of card to check, e.g. passing \n1\n will mean \n/dev/dri/card1\n.\n\n\nReturn value:\n\n\n\n\nAVAILABLE\n if the device node is EVDI and is available to use.\n\n\nUNRECOGNIZED\n when a node has not been created by EVDI kernel module.\n\n\nNOT_PRESENT\n in other cases, e.g. when the device does not exist or cannot be opened to check.\n\n\n\n\nAdding new EVDI node\n\u00b6\n\n\n1\nint\n \nevdi_add_device\n()\n\n\n\n\n\n\n\nUse this to tell the kernel module to create a new \ncardX\n node for your application to use.\n\n\nReturn value:\n\n\n1\n when successful, \n0\n otherwise.\n\n\nOpening device nodes\n\u00b6\n\n\n1\nevdi_handle\n \nevdi_open\n(\nint\n \ndevice\n);\n\n\n\n\n\n\n\nThis function attempts to open a DRM device node with given number as EVDI.\nFunction performs compatibility check with underlying drm device. If version of the\nlibrary and module does not match then the device will not be opened.\n\n\nArguments\n: \ndevice\n is a number of card to open, e.g. \n1\n means \n/dev/dri/card1\n.\n\n\nReturn value:\n an opened device handle to use in following API calls if opening was successful, \nEVDI_INVALID_HANDLE\n otherwise.\n\n\nClosing devices\n\u00b6\n\n\n1\nvoid\n \nevdi_close\n(\nevdi_handle\n \nhandle\n);\n\n\n\n\n\n\n\nCloses an opened EVDI handle.\n\n\nArguments\n: \nhandle\n to an opened device that is to be closed.\n\n\nConnection\n\u00b6\n\n\nOpening connections\n\u00b6\n\n\n1\n2\n3\n4\nvoid\n \nevdi_connect\n(\nevdi_handle\n \nhandle\n,\n\n          \nconst\n \nunsigned\n \nchar\n*\n \nedid\n,\n\n          \nconst\n \nunsigned\n \nedid_length\n,\n\n          \nconst\n \nuint32_t\n \nsku_area_limit\n);\n\n\n\n\n\n\n\nCreates a connection between the EVDI and Linux DRM subsystem, resulting in kernel mode driver processing a hot plug event.\n\n\nArguments\n:\n\n\n\n\nhandle\n to an opened device\n\n\nedid\n should be a pointer to a memory block with contents of an EDID of a monitor that will be exposed to kernel\n\n\nedid_length\n is the length of the EDID block (typically 512 bytes, or more if extension blocks are present)\n\n\nsku_area_limit\n is maximum pixel area (width x height) connected device can display\n\n\n\n\nDisconnecting\n\u00b6\n\n\n1\nvoid\n \nevdi_disconnect\n(\nevdi_handle\n \nhandle\n)\n\n\n\n\n\n\n\nBreaks the connection between the device handle and DRM subsystem - resulting in an unplug event being processed.\n\n\nArguments\n: \nhandle\n to an opened device.\n\n\nBuffers\n\u00b6\n\n\nManaging memory for frame buffers is left to the client applications.\nThe \nevdi_buffer\n structure is used to let the library know details about the frame buffer your application is working with.\nFor more details, see \nstruct evdi_buffer\n description.\n\n\nRegistering\n\u00b6\n\n\n1\nvoid\n \nevdi_register_buffer\n(\nevdi_handle\n \nhandle\n,\n \nevdi_buffer\n \nbuffer\n);\n\n\n\n\n\n\n\nThis function allows to register a \nbuffer\n of type \nevdi_buffer\n with an opened EVDI device \nhandle\n.\n\n\n\n\nWarning\n\n\nRegistering a buffer does not allocate memory for the frame.\n\n\n\n\nUnregistering\n\u00b6\n\n\n1\nvoid\n \nevdi_unregister_buffer\n(\nevdi_handle\n \nhandle\n,\n \nint\n \nbufferId\n);\n\n\n\n\n\n\n\nThis function unregisters a buffer with a given \nbufferId\n from an opened EVDI device \nhandle\n.\n\n\n\n\nWarning\n\n\nUnregistering a buffer does not deallocate memory for the frame.\n\n\n\n\nScreen updates\n\u00b6\n\n\nRequesting an update\n\u00b6\n\n\n1\nbool\n \nevdi_request_update\n(\nevdi_handle\n \nhandle\n,\n \nint\n \nbufferId\n);\n\n\n\n\n\n\n\nRequests an update for a buffer with a given \nbufferId\n. The buffer must be already registered with the library.\n\n\nArguments\n:\n\n\n\n\nhandle\n to an opened device.\n\n\nbufferId\n is an indentifier for a buffer that should be updated.\n\n\n\n\nReturn value:\n\n\nThe function can return \ntrue\n if the data for the buffer is ready to be grabbed immediately after the call.\nIf \nfalse\n is returned, then an update is not yet ready to grab and the application should wait until it gets\nnotified by the kernel module - see \nEvents and handlers\n.\n\n\nGrabbing pixels\n\u00b6\n\n\n1\nvoid\n \nevdi_grab_pixels\n(\nevdi_handle\n \nhandle\n,\n \nevdi_rect\n \n*\nrects\n,\n \nint\n \n*\nnum_rects\n);\n\n\n\n\n\n\n\nGrabs pixels following the most recent update request (see \nRequesting an update\n).\n\n\nThis should be called either after a call to \nevdi_request_update\n (if it returns \ntrue\n which means pixels can be grabbed immediately),\nor while handling the \nupdate_ready\n notification.\n\n\nArguments\n:\n\n\n\n\nhandle\n to an opened device.\n\n\nrects\n is a pointer to the first \nevdi_rect\n that the library fills, based on what the kernel tells.\n\n\n\n\n\n\nNote\n\n\nIt is expected that this pointer is a beginning of an array of \nevdi_rect\ns, and current implementation assumes\nthe array does not contain more than 16 slots for rects.\n\n\n\n\n\n\nnum_rects\n is a pointer to an integer that will be modified to tell how many dirty rectangles are valid in the list,\n   and the client should only care about as many. In particular, a failed grab will be indicated by \n0\n valid rectangles\n   to take into account (this can happen when there was a mode change between the request and the grab).\n\n\n\n\nEvents and handlers\n\u00b6\n\n\nDPMS\n mode change\n\u00b6\n\n\n1\nvoid\n \n(\n*\ndpms_handler\n)(\nint\n \ndpms_mode\n,\n \nvoid\n*\n \nuser_data\n);\n\n\n\n\n\n\n\nThis notification is sent when a \nDPMS\n mode changes.\nThe possible modes are as defined by the standard, and values are bit-compatible with DRM and Xorg:\n\n\n/* DPMS flags */\n\n\n#\ndefine\n \nDRM_MODE_DPMS_ON\n        \n0\n\n\n#\ndefine\n \nDRM_MODE_DPMS_STANDBY\n   \n1\n\n\n#\ndefine\n \nDRM_MODE_DPMS_SUSPEND\n   \n2\n\n\n#\ndefine\n \nDRM_MODE_DPMS_OFF\n       \n3\n\n\n\n\n\n\nMode change notification\n\u00b6\n\n\n1\nvoid\n \n(\n*\nmode_changed_handler\n)(\nevdi_mode\n \nmode\n,\n \nvoid\n*\n \nuser_data\n);\n\n\n\n\n\n\n\nThis notification is sent when a display mode changes. Details of the new mode are sent in the \nmode\n argument.\nSee \nevdi_mode\n for description of the structure.\n\n\nUpdate ready notification\n\u00b6\n\n\n1\nvoid\n \n(\n*\nupdate_ready_handler\n)(\nint\n \nbuffer_to_be_updated\n,\n \nvoid\n*\n \nuser_data\n);\n\n\n\n\n\n\n\nThis notification is sent when an update for a buffer, that had been earlier requested is ready to be consumed.\nThe buffer number to be updated is \nbuffer_to_be_updated\n.\n\n\nCursor change notification\n\u00b6\n\n\n1\nvoid\n \n(\n*\ncursor_set_handler\n)(\nstruct\n \nevdi_cursor_set\n \ncursor_set\n,\n \nvoid\n*\n \nuser_data\n);\n\n\n\n\n\n\n\nThis notification is sent for an update of cursor buffer or shape. It is also raised when cursor is enabled or disabled.\nSuch situation happens when cursor is moved on and off the screen respectively.\n\n\nCursor move notification\n\u00b6\n\n\n1\nvoid\n \n(\n*\ncursor_move_handler\n)(\nstruct\n \nevdi_cursor_move\n \ncursor_move\n,\n \nvoid\n*\n \nuser_data\n);\n\n\n\n\n\n\n\nThis notification is sent for a cursor position change. It is raised only when cursor is positioned on virtual screen.\n\n\nCRTC state change\n\u00b6\n\n\n1\nvoid\n \n(\n*\ncrtc_state_handler\n)(\nint\n \nstate\n,\n \nvoid\n*\n \nuser_data\n);\n\n\n\n\n\n\n\nSent when DRM's CRTC changes state. The \nstate\n is a value that's forwarded from the kernel.\n\n\nTypes\n\u00b6\n\n\nevdi_handle\n\u00b6\n\n\nThis is a handle to an opened device node that you get from an \nevdi_open\n call,\nand use in all following API calls to indicate which EVDI device you communicate with.\n\n\nevdi_selectable\n\u00b6\n\n\nA typedef denoting a file descriptor you can watch to know when there are events being signalled from the kernel module.\nEach opened EVDI device handle has its own descriptor to watch.\nWhen the descriptor becomes ready to read from, the application should call \nevdi_handle_events\n to dispatch notifications to its handlers.\n\n\nevdi_device_status\n\u00b6\n\n\nAn enumerated type used while finding the DRM device node that is EVDI. Possible values are \nAVAILABLE\n, \nUNRECOGNIZED\n and \nNOT_PRESENT\n.\n\n\nevdi_rect\n\u00b6\n\n\nA simple structure used by the library to represent a rectangular area of a screen. Top left coordinates of the rectangle are \nx1\n and \ny1\n,\nbottom right are \nx2\n and \ny2\n.\n\n\nevdi_mode\n\u00b6\n\n\nA structure used to describe a video mode that's set for a display. Contains details of resolution set (\nwidth\n, \nheight\n), refresh rate (\nrefresh_rate\n),\nand details of a pixel format used to encode color value (\nbits_per_pixel\n and \npixel_format\n - which are forwarded from kernel's DRM).\n\n\nevdi_buffer\n\u00b6\n\n\nA structure holding details about a buffer.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\ntypedef\n \nstruct\n \n{\n\n    \nint\n \nid\n;\n\n    \nvoid\n*\n \nbuffer\n;\n\n    \nint\n \nwidth\n;\n\n    \nint\n \nheight\n;\n\n    \nint\n \nstride\n;\n\n\n    \nevdi_rect\n*\n \nrects\n;\n\n    \nint\n \nrect_count\n;\n\n\n}\n \nevdi_buffer\n;\n\n\n\n\n\n\n\nBuffers have IDs, which can be arbitrarily chosen integer numbers - but typically a simple sequence of numbers starting\nfrom \n0\n is used in client applications. The pointer to the beginning of an already allocated memory block should be assigned\nto the \nbuffer\n member of the structure. This memory will be filled by the kernel module when handling requests to grab pixels.\n\n\nwidth\n, \nheight\n and \nstride\n are properties of the buffer - the first two indicate what the size of the frame is,\nand \nstride\n is a width stride - tells what is the increment in bytes between data for lines in memory.\n\n\nStride can be equal to width of a single line multiplied by the number of bytes necessary for encoding color value for one pixel (e.g. 4 for RGB32) if the data for lines are contigous in the memory,\nbut you can use larger value to indicate extra space/padding between them.\n\n\nLast two structure members, \nrects\n and \nrect_counts\n are updated during grabbing pixels to inform about the number and coordinates of areas that are changed from the last update.\n\n\nevdi_event_context\n\u00b6\n\n\n1\n2\n3\n4\n5\n6\n7\ntypedef\n \nstruct\n \n{\n\n  \nvoid\n \n(\n*\ndpms_handler\n)(\nint\n \ndpms_mode\n,\n \nvoid\n*\n \nuser_data\n);\n\n  \nvoid\n \n(\n*\nmode_changed_handler\n)(\nevdi_mode\n \nmode\n,\n \nvoid\n*\n \nuser_data\n);\n\n  \nvoid\n \n(\n*\nupdate_ready_handler\n)(\nint\n \nbuffer_to_be_updated\n,\n \nvoid\n*\n \nuser_data\n);\n\n  \nvoid\n \n(\n*\ncrtc_state_handler\n)(\nint\n \nstate\n,\n \nvoid\n*\n \nuser_data\n);\n\n  \nvoid\n*\n \nuser_data\n;\n\n\n}\n \nevdi_event_context\n;\n\n\n\n\n\n\n\nThe \nevdi_device_context\n structure is used for holding pointers to handlers for all notifications that the application may receive from\nthe kernel module. The \nuser_data\n member is a value that the library will use while dispatching the call back.\nSee \nEvents and handlers\n for more information.\n\n\nevdi_lib_version\n\u00b6\n\n\n1\n2\n3\n4\n5\nstruct\n \nevdi_lib_version\n \n{\n\n    \nint\n \nversion_major\n;\n\n    \nint\n \nversion_minor\n;\n\n    \nint\n \nversion_patchlevel\n;\n\n\n};\n\n\n\n\n\n\n\nThe \nevdi_lib_version\n structure contains libevdi version.\nVersion can be used to check compatibility between library and a client application.\n\n\nevdi_cursor_set\n\u00b6\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\nstruct\n \nevdi_cursor_set\n \n{\n\n    \nint32_t\n \nhot_x\n;\n\n    \nint32_t\n \nhot_y\n;\n\n    \nuint32_t\n \nwidth\n;\n\n    \nuint32_t\n \nheight\n;\n\n    \nuint8_t\n \nenabled\n;\n\n    \nuint32_t\n \nbuffer_length\n;\n\n    \nuint32_t\n \n*\nbuffer\n;\n\n    \nuint32_t\n \npixel_format\n;\n\n    \nuint32_t\n \nstride\n;\n\n\n};\n\n\n\n\n\n\n\nThe \nevdi_cursor_set\n structure contains cursor state information. \nhot_x\n and \nhot_y\n define hotspot information.\n\nenabled\n parameter is true when cursor bitmap is available and cursor is visible on virtual display.\nParameters \nwidth\n and \nheight\n define size of the cursor bitmap stored in a \nbuffer\n memory area of size \nbuffer_length\n.\n\n\n\n\nWarning\n\n\nEvent handler or library user has to free buffer memory when it is not using it.\n\n\n\n\nRemaining \nstride\n and \npixel_format\n describe data organization in the buffer. \nstride\n is a size of a single line in a buffer.\nUsually it is width of the cursor multiplied by bytes per pixel value plus additional extra padding. It ensures proper alignment of subsequent pixel rows.\nPixel encoding is described by FourCC code in \npixel_format\n field. Usually it is \nARGB_8888\n however the value is system dependent and might change in the future.\n\n\nevdi_cursor_move\n\u00b6\n\n\n1\n2\n3\n4\nstruct\n \nevdi_cursor_move\n \n{\n\n    \nint32_t\n \nx\n;\n\n    \nint32_t\n \ny\n;\n\n\n};\n\n\n\n\n\n\n\nThe \nevdi_cursor_move\n structure contains current cursor position.\nIt is defined as top left corner of the cursor bitmap.",
            "title": "Detailed description"
        },
        {
            "location": "/details/#api-details",
            "text": "",
            "title": "API Details"
        },
        {
            "location": "/details/#functions-by-group",
            "text": "",
            "title": "Functions by group"
        },
        {
            "location": "/details/#versioning",
            "text": "1 evdi_get_lib_version ( struct   evdi_lib_version   device );    Function returns library version. \nIt uses semantic versioning to mark compatibility changes.\nVersion consists of 3 components formatted as MAJOR.MINOR.PATCH   MAJOR  number is changed for incompatibile API changes  MINOR  number is changed for backwards-compatible changes  PATCH  number is changed for backwards-compatibile bug fixes",
            "title": "Versioning"
        },
        {
            "location": "/details/#module-parameters",
            "text": "User can modify driver behaviour by its parameters that can be set at module load time or changed during runtime.   enable_cursor_blending  Enables cursor compositing on user supplied framebuffer via  EVDI_GRABPIX  ioctl (default: true)",
            "title": "Module parameters"
        },
        {
            "location": "/details/#evdi-nodes",
            "text": "",
            "title": "EVDI nodes"
        },
        {
            "location": "/details/#finding-an-available-evdi-node-to-use",
            "text": "1 evdi_device_status   evdi_check_device ( int   device );    Use this function to check if a particular  /dev/dri/cardX  is EVDI or not.  Arguments:   device  is a number of card to check, e.g. passing  1  will mean  /dev/dri/card1 .  Return value:   AVAILABLE  if the device node is EVDI and is available to use.  UNRECOGNIZED  when a node has not been created by EVDI kernel module.  NOT_PRESENT  in other cases, e.g. when the device does not exist or cannot be opened to check.",
            "title": "Finding an available EVDI node to use"
        },
        {
            "location": "/details/#adding-new-evdi-node",
            "text": "1 int   evdi_add_device ()    Use this to tell the kernel module to create a new  cardX  node for your application to use.  Return value:  1  when successful,  0  otherwise.",
            "title": "Adding new EVDI node"
        },
        {
            "location": "/details/#opening-device-nodes",
            "text": "1 evdi_handle   evdi_open ( int   device );    This function attempts to open a DRM device node with given number as EVDI.\nFunction performs compatibility check with underlying drm device. If version of the\nlibrary and module does not match then the device will not be opened.  Arguments :  device  is a number of card to open, e.g.  1  means  /dev/dri/card1 .  Return value:  an opened device handle to use in following API calls if opening was successful,  EVDI_INVALID_HANDLE  otherwise.",
            "title": "Opening device nodes"
        },
        {
            "location": "/details/#closing-devices",
            "text": "1 void   evdi_close ( evdi_handle   handle );    Closes an opened EVDI handle.  Arguments :  handle  to an opened device that is to be closed.",
            "title": "Closing devices"
        },
        {
            "location": "/details/#connection",
            "text": "",
            "title": "Connection"
        },
        {
            "location": "/details/#opening-connections",
            "text": "1\n2\n3\n4 void   evdi_connect ( evdi_handle   handle , \n           const   unsigned   char *   edid , \n           const   unsigned   edid_length , \n           const   uint32_t   sku_area_limit );    Creates a connection between the EVDI and Linux DRM subsystem, resulting in kernel mode driver processing a hot plug event.  Arguments :   handle  to an opened device  edid  should be a pointer to a memory block with contents of an EDID of a monitor that will be exposed to kernel  edid_length  is the length of the EDID block (typically 512 bytes, or more if extension blocks are present)  sku_area_limit  is maximum pixel area (width x height) connected device can display",
            "title": "Opening connections"
        },
        {
            "location": "/details/#disconnecting",
            "text": "1 void   evdi_disconnect ( evdi_handle   handle )    Breaks the connection between the device handle and DRM subsystem - resulting in an unplug event being processed.  Arguments :  handle  to an opened device.",
            "title": "Disconnecting"
        },
        {
            "location": "/details/#buffers",
            "text": "Managing memory for frame buffers is left to the client applications.\nThe  evdi_buffer  structure is used to let the library know details about the frame buffer your application is working with.\nFor more details, see  struct evdi_buffer  description.",
            "title": "Buffers"
        },
        {
            "location": "/details/#registering",
            "text": "1 void   evdi_register_buffer ( evdi_handle   handle ,   evdi_buffer   buffer );    This function allows to register a  buffer  of type  evdi_buffer  with an opened EVDI device  handle .   Warning  Registering a buffer does not allocate memory for the frame.",
            "title": "Registering"
        },
        {
            "location": "/details/#unregistering",
            "text": "1 void   evdi_unregister_buffer ( evdi_handle   handle ,   int   bufferId );    This function unregisters a buffer with a given  bufferId  from an opened EVDI device  handle .   Warning  Unregistering a buffer does not deallocate memory for the frame.",
            "title": "Unregistering"
        },
        {
            "location": "/details/#screen-updates",
            "text": "",
            "title": "Screen updates"
        },
        {
            "location": "/details/#requesting-an-update",
            "text": "1 bool   evdi_request_update ( evdi_handle   handle ,   int   bufferId );    Requests an update for a buffer with a given  bufferId . The buffer must be already registered with the library.  Arguments :   handle  to an opened device.  bufferId  is an indentifier for a buffer that should be updated.   Return value:  The function can return  true  if the data for the buffer is ready to be grabbed immediately after the call.\nIf  false  is returned, then an update is not yet ready to grab and the application should wait until it gets\nnotified by the kernel module - see  Events and handlers .",
            "title": "Requesting an update"
        },
        {
            "location": "/details/#grabbing-pixels",
            "text": "1 void   evdi_grab_pixels ( evdi_handle   handle ,   evdi_rect   * rects ,   int   * num_rects );    Grabs pixels following the most recent update request (see  Requesting an update ).  This should be called either after a call to  evdi_request_update  (if it returns  true  which means pixels can be grabbed immediately),\nor while handling the  update_ready  notification.  Arguments :   handle  to an opened device.  rects  is a pointer to the first  evdi_rect  that the library fills, based on what the kernel tells.    Note  It is expected that this pointer is a beginning of an array of  evdi_rect s, and current implementation assumes\nthe array does not contain more than 16 slots for rects.    num_rects  is a pointer to an integer that will be modified to tell how many dirty rectangles are valid in the list,\n   and the client should only care about as many. In particular, a failed grab will be indicated by  0  valid rectangles\n   to take into account (this can happen when there was a mode change between the request and the grab).",
            "title": "Grabbing pixels"
        },
        {
            "location": "/details/#events-and-handlers",
            "text": "",
            "title": "Events and handlers"
        },
        {
            "location": "/details/#dpms-mode-change",
            "text": "1 void   ( * dpms_handler )( int   dpms_mode ,   void *   user_data );    This notification is sent when a  DPMS  mode changes.\nThe possible modes are as defined by the standard, and values are bit-compatible with DRM and Xorg:  /* DPMS flags */  # define   DRM_MODE_DPMS_ON          0  # define   DRM_MODE_DPMS_STANDBY     1  # define   DRM_MODE_DPMS_SUSPEND     2  # define   DRM_MODE_DPMS_OFF         3",
            "title": "DPMS mode change"
        },
        {
            "location": "/details/#mode-change-notification",
            "text": "1 void   ( * mode_changed_handler )( evdi_mode   mode ,   void *   user_data );    This notification is sent when a display mode changes. Details of the new mode are sent in the  mode  argument.\nSee  evdi_mode  for description of the structure.",
            "title": "Mode change notification"
        },
        {
            "location": "/details/#update-ready-notification",
            "text": "1 void   ( * update_ready_handler )( int   buffer_to_be_updated ,   void *   user_data );    This notification is sent when an update for a buffer, that had been earlier requested is ready to be consumed.\nThe buffer number to be updated is  buffer_to_be_updated .",
            "title": "Update ready notification"
        },
        {
            "location": "/details/#cursor-change-notification",
            "text": "1 void   ( * cursor_set_handler )( struct   evdi_cursor_set   cursor_set ,   void *   user_data );    This notification is sent for an update of cursor buffer or shape. It is also raised when cursor is enabled or disabled.\nSuch situation happens when cursor is moved on and off the screen respectively.",
            "title": "Cursor change notification"
        },
        {
            "location": "/details/#cursor-move-notification",
            "text": "1 void   ( * cursor_move_handler )( struct   evdi_cursor_move   cursor_move ,   void *   user_data );    This notification is sent for a cursor position change. It is raised only when cursor is positioned on virtual screen.",
            "title": "Cursor move notification"
        },
        {
            "location": "/details/#crtc-state-change",
            "text": "1 void   ( * crtc_state_handler )( int   state ,   void *   user_data );    Sent when DRM's CRTC changes state. The  state  is a value that's forwarded from the kernel.",
            "title": "CRTC state change"
        },
        {
            "location": "/details/#types",
            "text": "",
            "title": "Types"
        },
        {
            "location": "/details/#evdi_handle",
            "text": "This is a handle to an opened device node that you get from an  evdi_open  call,\nand use in all following API calls to indicate which EVDI device you communicate with.",
            "title": "evdi_handle"
        },
        {
            "location": "/details/#evdi_selectable",
            "text": "A typedef denoting a file descriptor you can watch to know when there are events being signalled from the kernel module.\nEach opened EVDI device handle has its own descriptor to watch.\nWhen the descriptor becomes ready to read from, the application should call  evdi_handle_events  to dispatch notifications to its handlers.",
            "title": "evdi_selectable"
        },
        {
            "location": "/details/#evdi_device_status",
            "text": "An enumerated type used while finding the DRM device node that is EVDI. Possible values are  AVAILABLE ,  UNRECOGNIZED  and  NOT_PRESENT .",
            "title": "evdi_device_status"
        },
        {
            "location": "/details/#evdi_rect",
            "text": "A simple structure used by the library to represent a rectangular area of a screen. Top left coordinates of the rectangle are  x1  and  y1 ,\nbottom right are  x2  and  y2 .",
            "title": "evdi_rect"
        },
        {
            "location": "/details/#evdi_mode",
            "text": "A structure used to describe a video mode that's set for a display. Contains details of resolution set ( width ,  height ), refresh rate ( refresh_rate ),\nand details of a pixel format used to encode color value ( bits_per_pixel  and  pixel_format  - which are forwarded from kernel's DRM).",
            "title": "evdi_mode"
        },
        {
            "location": "/details/#evdi_buffer",
            "text": "A structure holding details about a buffer.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10 typedef   struct   { \n     int   id ; \n     void *   buffer ; \n     int   width ; \n     int   height ; \n     int   stride ; \n\n     evdi_rect *   rects ; \n     int   rect_count ;  }   evdi_buffer ;    Buffers have IDs, which can be arbitrarily chosen integer numbers - but typically a simple sequence of numbers starting\nfrom  0  is used in client applications. The pointer to the beginning of an already allocated memory block should be assigned\nto the  buffer  member of the structure. This memory will be filled by the kernel module when handling requests to grab pixels.  width ,  height  and  stride  are properties of the buffer - the first two indicate what the size of the frame is,\nand  stride  is a width stride - tells what is the increment in bytes between data for lines in memory.  Stride can be equal to width of a single line multiplied by the number of bytes necessary for encoding color value for one pixel (e.g. 4 for RGB32) if the data for lines are contigous in the memory,\nbut you can use larger value to indicate extra space/padding between them.  Last two structure members,  rects  and  rect_counts  are updated during grabbing pixels to inform about the number and coordinates of areas that are changed from the last update.",
            "title": "evdi_buffer"
        },
        {
            "location": "/details/#evdi_event_context",
            "text": "1\n2\n3\n4\n5\n6\n7 typedef   struct   { \n   void   ( * dpms_handler )( int   dpms_mode ,   void *   user_data ); \n   void   ( * mode_changed_handler )( evdi_mode   mode ,   void *   user_data ); \n   void   ( * update_ready_handler )( int   buffer_to_be_updated ,   void *   user_data ); \n   void   ( * crtc_state_handler )( int   state ,   void *   user_data ); \n   void *   user_data ;  }   evdi_event_context ;    The  evdi_device_context  structure is used for holding pointers to handlers for all notifications that the application may receive from\nthe kernel module. The  user_data  member is a value that the library will use while dispatching the call back.\nSee  Events and handlers  for more information.",
            "title": "evdi_event_context"
        },
        {
            "location": "/details/#evdi_lib_version",
            "text": "1\n2\n3\n4\n5 struct   evdi_lib_version   { \n     int   version_major ; \n     int   version_minor ; \n     int   version_patchlevel ;  };    The  evdi_lib_version  structure contains libevdi version.\nVersion can be used to check compatibility between library and a client application.",
            "title": "evdi_lib_version"
        },
        {
            "location": "/details/#evdi_cursor_set",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 struct   evdi_cursor_set   { \n     int32_t   hot_x ; \n     int32_t   hot_y ; \n     uint32_t   width ; \n     uint32_t   height ; \n     uint8_t   enabled ; \n     uint32_t   buffer_length ; \n     uint32_t   * buffer ; \n     uint32_t   pixel_format ; \n     uint32_t   stride ;  };    The  evdi_cursor_set  structure contains cursor state information.  hot_x  and  hot_y  define hotspot information. enabled  parameter is true when cursor bitmap is available and cursor is visible on virtual display.\nParameters  width  and  height  define size of the cursor bitmap stored in a  buffer  memory area of size  buffer_length .   Warning  Event handler or library user has to free buffer memory when it is not using it.   Remaining  stride  and  pixel_format  describe data organization in the buffer.  stride  is a size of a single line in a buffer.\nUsually it is width of the cursor multiplied by bytes per pixel value plus additional extra padding. It ensures proper alignment of subsequent pixel rows.\nPixel encoding is described by FourCC code in  pixel_format  field. Usually it is  ARGB_8888  however the value is system dependent and might change in the future.",
            "title": "evdi_cursor_set"
        },
        {
            "location": "/details/#evdi_cursor_move",
            "text": "1\n2\n3\n4 struct   evdi_cursor_move   { \n     int32_t   x ; \n     int32_t   y ;  };    The  evdi_cursor_move  structure contains current cursor position.\nIt is defined as top left corner of the cursor bitmap.",
            "title": "evdi_cursor_move"
        }
    ]
}