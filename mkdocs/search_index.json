{
    "docs": [
        {
            "location": "/", 
            "text": "Introduction\n\n\nExtensible Virtual Display Interface (EVDI in short) is a software project that allows any userspace Linux program manage additional displays, and receive updates for them.\nThis short document explains how to use EVDI library in your application.\n\n\nFor more details about EVDI project and the latest code, see the \nproject page\n on DisplayLink's GitHub.\n\n\nProject origin\n\n\nEVDI is a project that was started by DisplayLink as a base for the development of DisplayLink's Display driver for Ubuntu Linux, driving all\ncurrent generation, USB 3.0 Universal Docking Stations and USB Display Adapters.\n\n\nHowever, it soon became apparent that we're making a generic interface that any other application could use - and that's when DisplayLink decided to open-source the code and push it to GitHub.\n\n\n\n\nInfo\n\n\nThe interface of the library is still changing. Please treat the API as not yet stable - in terms of allowing the possibility that\nit can still be modified, and your clients may require matching updates.", 
            "title": "Home"
        }, 
        {
            "location": "/#introduction", 
            "text": "Extensible Virtual Display Interface (EVDI in short) is a software project that allows any userspace Linux program manage additional displays, and receive updates for them.\nThis short document explains how to use EVDI library in your application.  For more details about EVDI project and the latest code, see the  project page  on DisplayLink's GitHub.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#project-origin", 
            "text": "EVDI is a project that was started by DisplayLink as a base for the development of DisplayLink's Display driver for Ubuntu Linux, driving all\ncurrent generation, USB 3.0 Universal Docking Stations and USB Display Adapters.  However, it soon became apparent that we're making a generic interface that any other application could use - and that's when DisplayLink decided to open-source the code and push it to GitHub.   Info  The interface of the library is still changing. Please treat the API as not yet stable - in terms of allowing the possibility that\nit can still be modified, and your clients may require matching updates.", 
            "title": "Project origin"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quick Start\n\n\nTypical application\n\n\nEVDI nodes\n\n\nAdding new nodes\n\n\nOpening and closing EVDI node\n\n\n\n\n\n\nConnecting and disconnecting\n\n\nFrame buffers\n\n\nRunning loop\n\n\nEvents and notifications\n\n\nTypes of events\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuick Start\n\n\nThis section explains how to write a basic client for EVDI. Details of API calls are ommitted here for brevity.\n\n\nTypical application\n\n\nApplications using EVDI will typically:\n\n\n\n\nfind a free EVDI node, or add a new node if none was found; then open it\n\n\nconnect to the EVDI node, letting the DRM subsystem know what is the monitor that the application drives\n\n\nallocate memory for, and register buffer(s) that will be used to receive screen updates\n\n\nrequest and consume updates and other notifications in a loop\n\n\n\n\nEVDI nodes\n\n\nEVDI reuses DRM subsystem's \ncardX\n nodes for passing messages between the kernel and userspace.\nIn order to distinguish non-EVDI nodes from a node that's created by EVDI kernel module, \nevdi_check_device\n function should be used.\n\n\nThe library only allows to connect to DRM nodes that are created by EVDI.\nAttempts to connect to other nodes (e.g. related to a built-in GPU) will fail.\n\n\n\n\nNote\n\n\nUsing EVDI nodes currently requires administrative rights, so applications must be run with \nsudo\n, or by root.\n\n\n\n\nAdding new nodes\n\n\nIn order to create a new EVDI \ncardX\n node, call \nevdi_add_device\n function.\nA single call adds one additional DRM card node that can later be used to connect to.\n\n\nAt the moment, every extra screen that you want to manage needs a separate node.\n\n\nOpening and closing EVDI node\n\n\nOnce an available EVDI node is identified, your application should call \nevdi_open\n, passing a number of \ncardX\n that you want to open.\nThis returns an \nevdi_handle\n that you will use for following API calls, or \nEVDI_INVALID_HANDLE\n if opening failed.\n\n\nIn order to close the handle, call \nevdi_close\n.\n\n\nConnecting and disconnecting\n\n\nConnecting to EVDI tells DRM subsystem that there is a monitor connected, and from this moment the system is aware of an extra display.\nConnection also lets DRM know what is the \nEDID\n of the monitor that a particular EVDI node handles.\nThink of this as something similar to plugging a monitor with a cable to a port of a graphics card.\n\n\nSimilarly, disconnecting indicates that the display is no longer there - like physically pulling cable out from the graphics adapter port.\n\n\nTo connect or disconnect, use \nevdi_connect\n and \nevdi_disconnect\n, respectively.\n\n\nFrame buffers\n\n\nTo know what the contents of the screen is, your application will use a block of memory that it can read pixel data from.\n\n\nThe library itself does \nnot\n allocate any memory for buffers - this is to allow more control in the client application.\nTherefore, before you request screen updates for the screens you're managing, an appropriate amount of memory must be allocated to hold screen data within your application.\nThe application can register as many buffers as you like, and subsequent update requests can refer to any buffer that was previously registered.\n\n\nAllocated memory is made available for EVDI library to use by calling \nevdi_register_buffer\n. Symetrically, \nevdi_unregister_buffer\n is used to tell the library not to use the buffer anymore.\n\n\nRunning loop\n\n\nAfter registering buffers, the application should start requesting updates for them. This is done using \nevdi_request_update\n.\nYou should call it when you intend to consume pixels for the screen.\n\n\nOnce the request to update buffer is handled by the kernel module, you can use \nevdi_grab_pixels\n to get the data in your app.\nThis also includes finding out which areas of the buffer are in fact modified, compared to a previous update.\n\n\nEvents and notifications\n\n\nDue to its design and split of responsibilities between the kernel and userspace code, EVDI's working model is an asynchronous.\nTherefore, your application should monitor a file descriptor exposed by \nevdi_get_event_ready\n function, and once it becomes ready to read,\ncall \nevdi_handle_events\n to dispatch events that are being signalled to the right handlers.\n\n\nThe handlers are defined in your application and are shared with the library through a \nevdi_event_context\n structure that \nevdi_handle_events\n uses for dispatching the call.\n\n\nTypes of events\n\n\nThe notifications your application can (and should) be handling, are:\n\n\n\n\nUpdate ready notification (sent once a request to update a buffer is handled by kernel)\n\n\nMode changed notification (sent from DRM after screen mode is changed)\n\n\nDPMS notifications (telling the new power state of a connector)\n\n\nCRTC state change event (exposing DRM CRTC state)\n\n\n\n\nYou will start receiving first notifications from the kernel module right after connecting to EVDI.\nYour application should use this information before you ask for screen updates to make sure the buffers are the right size.", 
            "title": "Quick Start"
        }, 
        {
            "location": "/quickstart/#quick-start", 
            "text": "This section explains how to write a basic client for EVDI. Details of API calls are ommitted here for brevity.", 
            "title": "Quick Start"
        }, 
        {
            "location": "/quickstart/#typical-application", 
            "text": "Applications using EVDI will typically:   find a free EVDI node, or add a new node if none was found; then open it  connect to the EVDI node, letting the DRM subsystem know what is the monitor that the application drives  allocate memory for, and register buffer(s) that will be used to receive screen updates  request and consume updates and other notifications in a loop", 
            "title": "Typical application"
        }, 
        {
            "location": "/quickstart/#evdi-nodes", 
            "text": "EVDI reuses DRM subsystem's  cardX  nodes for passing messages between the kernel and userspace.\nIn order to distinguish non-EVDI nodes from a node that's created by EVDI kernel module,  evdi_check_device  function should be used.  The library only allows to connect to DRM nodes that are created by EVDI.\nAttempts to connect to other nodes (e.g. related to a built-in GPU) will fail.   Note  Using EVDI nodes currently requires administrative rights, so applications must be run with  sudo , or by root.", 
            "title": "EVDI nodes"
        }, 
        {
            "location": "/quickstart/#adding-new-nodes", 
            "text": "In order to create a new EVDI  cardX  node, call  evdi_add_device  function.\nA single call adds one additional DRM card node that can later be used to connect to.  At the moment, every extra screen that you want to manage needs a separate node.", 
            "title": "Adding new nodes"
        }, 
        {
            "location": "/quickstart/#opening-and-closing-evdi-node", 
            "text": "Once an available EVDI node is identified, your application should call  evdi_open , passing a number of  cardX  that you want to open.\nThis returns an  evdi_handle  that you will use for following API calls, or  EVDI_INVALID_HANDLE  if opening failed.  In order to close the handle, call  evdi_close .", 
            "title": "Opening and closing EVDI node"
        }, 
        {
            "location": "/quickstart/#connecting-and-disconnecting", 
            "text": "Connecting to EVDI tells DRM subsystem that there is a monitor connected, and from this moment the system is aware of an extra display.\nConnection also lets DRM know what is the  EDID  of the monitor that a particular EVDI node handles.\nThink of this as something similar to plugging a monitor with a cable to a port of a graphics card.  Similarly, disconnecting indicates that the display is no longer there - like physically pulling cable out from the graphics adapter port.  To connect or disconnect, use  evdi_connect  and  evdi_disconnect , respectively.", 
            "title": "Connecting and disconnecting"
        }, 
        {
            "location": "/quickstart/#frame-buffers", 
            "text": "To know what the contents of the screen is, your application will use a block of memory that it can read pixel data from.  The library itself does  not  allocate any memory for buffers - this is to allow more control in the client application.\nTherefore, before you request screen updates for the screens you're managing, an appropriate amount of memory must be allocated to hold screen data within your application.\nThe application can register as many buffers as you like, and subsequent update requests can refer to any buffer that was previously registered.  Allocated memory is made available for EVDI library to use by calling  evdi_register_buffer . Symetrically,  evdi_unregister_buffer  is used to tell the library not to use the buffer anymore.", 
            "title": "Frame buffers"
        }, 
        {
            "location": "/quickstart/#running-loop", 
            "text": "After registering buffers, the application should start requesting updates for them. This is done using  evdi_request_update .\nYou should call it when you intend to consume pixels for the screen.  Once the request to update buffer is handled by the kernel module, you can use  evdi_grab_pixels  to get the data in your app.\nThis also includes finding out which areas of the buffer are in fact modified, compared to a previous update.", 
            "title": "Running loop"
        }, 
        {
            "location": "/quickstart/#events-and-notifications", 
            "text": "Due to its design and split of responsibilities between the kernel and userspace code, EVDI's working model is an asynchronous.\nTherefore, your application should monitor a file descriptor exposed by  evdi_get_event_ready  function, and once it becomes ready to read,\ncall  evdi_handle_events  to dispatch events that are being signalled to the right handlers.  The handlers are defined in your application and are shared with the library through a  evdi_event_context  structure that  evdi_handle_events  uses for dispatching the call.", 
            "title": "Events and notifications"
        }, 
        {
            "location": "/quickstart/#types-of-events", 
            "text": "The notifications your application can (and should) be handling, are:   Update ready notification (sent once a request to update a buffer is handled by kernel)  Mode changed notification (sent from DRM after screen mode is changed)  DPMS notifications (telling the new power state of a connector)  CRTC state change event (exposing DRM CRTC state)   You will start receiving first notifications from the kernel module right after connecting to EVDI.\nYour application should use this information before you ask for screen updates to make sure the buffers are the right size.", 
            "title": "Types of events"
        }, 
        {
            "location": "/details/", 
            "text": "API Details\n\n\nFunctions by group\n\n\nEVDI nodes\n\n\nFinding an available EVDI node to use\n\n\nAdding new EVDI node\n\n\nOpening device nodes\n\n\nClosing devices\n\n\n\n\n\n\nConnection\n\n\nOpening connections\n\n\nDisconnecting\n\n\n\n\n\n\nBuffers\n\n\nRegistering\n\n\nUnregistering\n\n\n\n\n\n\nScreen updates\n\n\nRequesting an update\n\n\nGrabbing pixels\n\n\n\n\n\n\nEvents and handlers\n\n\nDPMS mode change\n\n\nMode change notification\n\n\nUpdate ready notification\n\n\nCRTC state change\n\n\n\n\n\n\n\n\n\n\nTypes\n\n\nevdi_handle\n\n\nevdi_selectable\n\n\nevdi_device_status\n\n\nevdi_rect\n\n\nevdi_mode\n\n\nevdi_buffer\n\n\nevdi_event_context\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAPI Details\n\n\nFunctions by group\n\n\nEVDI nodes\n\n\nFinding an available EVDI node to use\n\n\nevdi_device_status evdi_check_device(int device);\n\n\n\n\nUse this function to check if a particular \n/dev/dri/cardX\n is EVDI or not.\n\n\nArguments:\n \ndevice\n is a number of card to check, e.g. passing \n1\n will mean \n/dev/dri/card1\n.\n\n\nReturn value:\n\n\n\n\nAVAILABLE\n if the device node is EVDI and is available to use.\n\n\nUNRECOGNIZED\n when a node has not been created by EVDI kernel module.\n\n\nNOT_PRESENT\n in other cases, e.g. when the device does not exist or cannot be opened to check.\n\n\n\n\nAdding new EVDI node\n\n\nint evdi_add_device()\n\n\n\n\nUse this to tell the kernel module to create a new \ncardX\n node for your application to use.\n\n\nReturn value:\n\n\n1\n when successful, \n0\n otherwise.\n\n\nOpening device nodes\n\n\nevdi_handle evdi_open(int device);\n\n\n\n\nThis function attempts to open a DRM device node with given number as EVDI.\n\n\nArguments\n: \ndevice\n is a number of card to open, e.g. \n1\n means \n/dev/dri/card1\n.\n\n\nReturn value:\n an opened device handle to use in following API calls if opening was successful, \nEVDI_INVALID_HANDLE\n otherwise.\n\n\nClosing devices\n\n\nvoid evdi_close(evdi_handle handle);\n\n\n\n\nCloses an opened EVDI handle.\n\n\nArguments\n: \nhandle\n to an opened device that is to be closed.\n\n\nConnection\n\n\nOpening connections\n\n\nvoid evdi_connect(evdi_handle handle,\n          const unsigned char* edid,\n          const unsigned edid_length,\n          const evdi_mode* modes,\n          const int modes_length);\n\n\n\n\nCreates a connection between the EVDI and Linux DRM subsystem, resulting in kernel mode driver processing a hot plug event.\n\n\nArguments\n:\n\n\n\n\nhandle\n to an opened device\n\n\nedid\n should be a pointer to a memory block with contents of an EDID of a monitor that will be exposed to kernel\n\n\nedid_length\n is the length of the EDID block (typically 512 bytes, or more if extension blocks are present)\n\n\nmodes\n It is a pointer to c-style table with display modes that are supported by client but not listed in edid. Can be NULL\n\n\nmodes_length\n is the number of modes in modes table\n\n\n\n\nDisconnecting\n\n\nvoid evdi_disconnect(evdi_handle handle)\n\n\n\n\nBreaks the connection between the device handle and DRM subsystem - resulting in an unplug event being processed.\n\n\nArguments\n: \nhandle\n to an opened device.\n\n\nBuffers\n\n\nManaging memory for frame buffers is left to the client applications.\nThe \nevdi_buffer\n structure is used to let the library know details about the frame buffer your application is working with.\nFor more details, see \nstruct evdi_buffer\n description.\n\n\nRegistering\n\n\nvoid evdi_register_buffer(evdi_handle handle, evdi_buffer buffer);\n\n\n\n\nThis function allows to register a \nbuffer\n of type \nevdi_buffer\n with an opened EVDI device \nhandle\n.\n\n\n\n\nWarning\n\n\nRegistering a buffer does not allocate memory for the frame.\n\n\n\n\nUnregistering\n\n\nvoid evdi_unregister_buffer(evdi_handle handle, int bufferId);\n\n\n\n\nThis function unregisters a buffer with a given \nbufferId\n from an opened EVDI device \nhandle\n.\n\n\n\n\nWarning\n\n\nUnregistering a buffer does not deallocate memory for the frame.\n\n\n\n\nScreen updates\n\n\nRequesting an update\n\n\nbool evdi_request_update(evdi_handle handle, int bufferId);\n\n\n\n\nRequests an update for a buffer with a given \nbufferId\n. The buffer must be already registered with the library.\n\n\nArguments\n:\n\n\n\n\nhandle\n to an opened device.\n\n\nbufferId\n is an indentifier for a buffer that should be updated.\n\n\n\n\nReturn value:\n\n\nThe function can return \ntrue\n if the data for the buffer is ready to be grabbed immediately after the call.\nIf \nfalse\n is returned, then an update is not yet ready to grab and the application should wait until it gets\nnotified by the kernel module - see \nEvents and handlers\n.\n\n\nGrabbing pixels\n\n\nvoid evdi_grab_pixels(evdi_handle handle, evdi_rect *rects, int *num_rects);\n\n\n\n\nGrabs pixels following the most recent update request (see \nRequesting an update\n).\n\n\nThis should be called either after a call to \nevdi_request_update\n (if it returns \ntrue\n which means pixels can be grabbed immediately),\nor while handling the \nupdate_ready\n notification.\n\n\nArguments\n:\n\n\n\n\nhandle\n to an opened device.\n\n\nrects\n is a pointer to the first \nevdi_rect\n that the library fills, based on what the kernel tells.\n\n\n\n\n\n\nNote\n\n\nIt is expected that this pointer is a beginning of an array of \nevdi_rect\ns, and current implementation assumes\nthe array does not contain more than 16 slots for rects.\n\n\n\n\n\n\nnum_rects\n is a pointer to an integer that will be modified to tell how many dirty rectangles are valid in the list,\n   and the client should only care about as many. In particular, a failed grab will be indicated by \n0\n valid rectangles\n   to take into account (this can happen when there was a mode change between the request and the grab).\n\n\n\n\nEvents and handlers\n\n\nDPMS\n mode change\n\n\nvoid (*dpms_handler)(int dpms_mode, void* user_data);\n\n\n\n\nThis notification is sent when a \nDPMS\n mode changes.\nThe possible modes are as defined by the standard, and values are bit-compatible with DRM and Xorg:\n\n\n/* DPMS flags */\n#define DRM_MODE_DPMS_ON        0\n#define DRM_MODE_DPMS_STANDBY   1\n#define DRM_MODE_DPMS_SUSPEND   2\n#define DRM_MODE_DPMS_OFF       3\n\n\n\n\nMode change notification\n\n\nvoid (*mode_changed_handler)(evdi_mode mode, void* user_data);\n\n\n\n\nThis notification is sent when a display mode changes. Details of the new mode are sent in the \nmode\n argument.\nSee \nevdi_mode\n for description of the structure.\n\n\nUpdate ready notification\n\n\nvoid (*update_ready_handler)(int buffer_to_be_updated, void* user_data);\n\n\n\n\nThis notification is sent when an update for a buffer, that had been earlier requested is ready to be consumed.\nThe buffer number to be updated is \nbuffer_to_be_updated\n.\n\n\nCRTC state change\n\n\nvoid (*crtc_state_handler)(int state, void* user_data);\n\n\n\n\nSent when DRM's CRTC changes state. The \nstate\n is a value that's forwarded from the kernel.\n\n\nTypes\n\n\nevdi_handle\n\n\nThis is a handle to an opened device node that you get from an \nevdi_open\n call,\nand use in all following API calls to indicate which EVDI device you communicate with.\n\n\nevdi_selectable\n\n\nA typedef denoting a file descriptor you can watch to know when there are events being signalled from the kernel module.\nEach opened EVDI device handle has its own descriptor to watch.\nWhen the descriptor becomes ready to read from, the application should call \nevdi_handle_events\n to dispatch notifications to its handlers.\n\n\nevdi_device_status\n\n\nAn enumerated type used while finding the DRM device node that is EVDI. Possible values are \nAVAILABLE\n, \nUNRECOGNIZED\n and \nNOT_PRESENT\n.\n\n\nevdi_rect\n\n\nA simple structure used by the library to represent a rectangular area of a screen. Top left coordinates of the rectangle are \nx1\n and \ny1\n,\nbottom right are \nx2\n and \ny2\n.\n\n\nevdi_mode\n\n\nA structure used to describe a video mode that's set for a display. Contains details of resolution set (\nwidth\n, \nheight\n), refresh rate (\nrefresh_rate\n),\nand details of a pixel format used to encode color value (\nbits_per_pixel\n and \npixel_format\n - which are forwarded from kernel's DRM).\n\n\nevdi_buffer\n\n\nA structure holding details about a buffer.\n\n\ntypedef struct {\n    int id;\n    void* buffer;\n    int width;\n    int height;\n    int stride;\n\n    evdi_rect* rects;\n    int rect_count;\n} evdi_buffer;\n\n\n\n\nBuffers have IDs, which can be arbitrarily chosen integer numbers - but typically a simple sequence of numbers starting\nfrom \n0\n is used in client applications. The pointer to the beginning of an already allocated memory block should be assigned\nto the \nbuffer\n member of the structure. This memory will be filled by the kernel module when handling requests to grab pixels.\n\n\nwidth\n, \nheight\n and \nstride\n are properties of the buffer - the first two indicate what the size of the frame is,\nand \nstride\n is a width stride - tells what is the increment in bytes between data for lines in memory.\n\n\nStride can be equal to width of a single line multiplied by the number of bytes necessary for encoding color value for one pixel (e.g. 4 for RGB32) if the data for lines are contigous in the memory,\nbut you can use larger value to indicate extra space/padding between them.\n\n\nLast two structure members, \nrects\n and \nrect_counts\n are updated during grabbing pixels to inform about the number and coordinates of areas that are changed from the last update.\n\n\nevdi_event_context\n\n\ntypedef struct {\n  void (*dpms_handler)(int dpms_mode, void* user_data);\n  void (*mode_changed_handler)(evdi_mode mode, void* user_data);\n  void (*update_ready_handler)(int buffer_to_be_updated, void* user_data);\n  void (*crtc_state_handler)(int state, void* user_data);\n  void* user_data;\n} evdi_event_context;\n\n\n\n\nThe \nevdi_device_context\n structure is used for holding pointers to handlers for all notifications that the application may receive from\nthe kernel module. The \nuser_data\n member is a value that the library will use while dispatching the call back.\nSee \nEvents and handlers\n for more information.", 
            "title": "Detailed description"
        }, 
        {
            "location": "/details/#api-details", 
            "text": "", 
            "title": "API Details"
        }, 
        {
            "location": "/details/#functions-by-group", 
            "text": "", 
            "title": "Functions by group"
        }, 
        {
            "location": "/details/#evdi-nodes", 
            "text": "", 
            "title": "EVDI nodes"
        }, 
        {
            "location": "/details/#finding-an-available-evdi-node-to-use", 
            "text": "evdi_device_status evdi_check_device(int device);  Use this function to check if a particular  /dev/dri/cardX  is EVDI or not.  Arguments:   device  is a number of card to check, e.g. passing  1  will mean  /dev/dri/card1 .  Return value:   AVAILABLE  if the device node is EVDI and is available to use.  UNRECOGNIZED  when a node has not been created by EVDI kernel module.  NOT_PRESENT  in other cases, e.g. when the device does not exist or cannot be opened to check.", 
            "title": "Finding an available EVDI node to use"
        }, 
        {
            "location": "/details/#adding-new-evdi-node", 
            "text": "int evdi_add_device()  Use this to tell the kernel module to create a new  cardX  node for your application to use.  Return value:  1  when successful,  0  otherwise.", 
            "title": "Adding new EVDI node"
        }, 
        {
            "location": "/details/#opening-device-nodes", 
            "text": "evdi_handle evdi_open(int device);  This function attempts to open a DRM device node with given number as EVDI.  Arguments :  device  is a number of card to open, e.g.  1  means  /dev/dri/card1 .  Return value:  an opened device handle to use in following API calls if opening was successful,  EVDI_INVALID_HANDLE  otherwise.", 
            "title": "Opening device nodes"
        }, 
        {
            "location": "/details/#closing-devices", 
            "text": "void evdi_close(evdi_handle handle);  Closes an opened EVDI handle.  Arguments :  handle  to an opened device that is to be closed.", 
            "title": "Closing devices"
        }, 
        {
            "location": "/details/#connection", 
            "text": "", 
            "title": "Connection"
        }, 
        {
            "location": "/details/#opening-connections", 
            "text": "void evdi_connect(evdi_handle handle,\n          const unsigned char* edid,\n          const unsigned edid_length,\n          const evdi_mode* modes,\n          const int modes_length);  Creates a connection between the EVDI and Linux DRM subsystem, resulting in kernel mode driver processing a hot plug event.  Arguments :   handle  to an opened device  edid  should be a pointer to a memory block with contents of an EDID of a monitor that will be exposed to kernel  edid_length  is the length of the EDID block (typically 512 bytes, or more if extension blocks are present)  modes  It is a pointer to c-style table with display modes that are supported by client but not listed in edid. Can be NULL  modes_length  is the number of modes in modes table", 
            "title": "Opening connections"
        }, 
        {
            "location": "/details/#disconnecting", 
            "text": "void evdi_disconnect(evdi_handle handle)  Breaks the connection between the device handle and DRM subsystem - resulting in an unplug event being processed.  Arguments :  handle  to an opened device.", 
            "title": "Disconnecting"
        }, 
        {
            "location": "/details/#buffers", 
            "text": "Managing memory for frame buffers is left to the client applications.\nThe  evdi_buffer  structure is used to let the library know details about the frame buffer your application is working with.\nFor more details, see  struct evdi_buffer  description.", 
            "title": "Buffers"
        }, 
        {
            "location": "/details/#registering", 
            "text": "void evdi_register_buffer(evdi_handle handle, evdi_buffer buffer);  This function allows to register a  buffer  of type  evdi_buffer  with an opened EVDI device  handle .   Warning  Registering a buffer does not allocate memory for the frame.", 
            "title": "Registering"
        }, 
        {
            "location": "/details/#unregistering", 
            "text": "void evdi_unregister_buffer(evdi_handle handle, int bufferId);  This function unregisters a buffer with a given  bufferId  from an opened EVDI device  handle .   Warning  Unregistering a buffer does not deallocate memory for the frame.", 
            "title": "Unregistering"
        }, 
        {
            "location": "/details/#screen-updates", 
            "text": "", 
            "title": "Screen updates"
        }, 
        {
            "location": "/details/#requesting-an-update", 
            "text": "bool evdi_request_update(evdi_handle handle, int bufferId);  Requests an update for a buffer with a given  bufferId . The buffer must be already registered with the library.  Arguments :   handle  to an opened device.  bufferId  is an indentifier for a buffer that should be updated.   Return value:  The function can return  true  if the data for the buffer is ready to be grabbed immediately after the call.\nIf  false  is returned, then an update is not yet ready to grab and the application should wait until it gets\nnotified by the kernel module - see  Events and handlers .", 
            "title": "Requesting an update"
        }, 
        {
            "location": "/details/#grabbing-pixels", 
            "text": "void evdi_grab_pixels(evdi_handle handle, evdi_rect *rects, int *num_rects);  Grabs pixels following the most recent update request (see  Requesting an update ).  This should be called either after a call to  evdi_request_update  (if it returns  true  which means pixels can be grabbed immediately),\nor while handling the  update_ready  notification.  Arguments :   handle  to an opened device.  rects  is a pointer to the first  evdi_rect  that the library fills, based on what the kernel tells.    Note  It is expected that this pointer is a beginning of an array of  evdi_rect s, and current implementation assumes\nthe array does not contain more than 16 slots for rects.    num_rects  is a pointer to an integer that will be modified to tell how many dirty rectangles are valid in the list,\n   and the client should only care about as many. In particular, a failed grab will be indicated by  0  valid rectangles\n   to take into account (this can happen when there was a mode change between the request and the grab).", 
            "title": "Grabbing pixels"
        }, 
        {
            "location": "/details/#events-and-handlers", 
            "text": "", 
            "title": "Events and handlers"
        }, 
        {
            "location": "/details/#dpms-mode-change", 
            "text": "void (*dpms_handler)(int dpms_mode, void* user_data);  This notification is sent when a  DPMS  mode changes.\nThe possible modes are as defined by the standard, and values are bit-compatible with DRM and Xorg:  /* DPMS flags */\n#define DRM_MODE_DPMS_ON        0\n#define DRM_MODE_DPMS_STANDBY   1\n#define DRM_MODE_DPMS_SUSPEND   2\n#define DRM_MODE_DPMS_OFF       3", 
            "title": "DPMS mode change"
        }, 
        {
            "location": "/details/#mode-change-notification", 
            "text": "void (*mode_changed_handler)(evdi_mode mode, void* user_data);  This notification is sent when a display mode changes. Details of the new mode are sent in the  mode  argument.\nSee  evdi_mode  for description of the structure.", 
            "title": "Mode change notification"
        }, 
        {
            "location": "/details/#update-ready-notification", 
            "text": "void (*update_ready_handler)(int buffer_to_be_updated, void* user_data);  This notification is sent when an update for a buffer, that had been earlier requested is ready to be consumed.\nThe buffer number to be updated is  buffer_to_be_updated .", 
            "title": "Update ready notification"
        }, 
        {
            "location": "/details/#crtc-state-change", 
            "text": "void (*crtc_state_handler)(int state, void* user_data);  Sent when DRM's CRTC changes state. The  state  is a value that's forwarded from the kernel.", 
            "title": "CRTC state change"
        }, 
        {
            "location": "/details/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/details/#evdi_handle", 
            "text": "This is a handle to an opened device node that you get from an  evdi_open  call,\nand use in all following API calls to indicate which EVDI device you communicate with.", 
            "title": "evdi_handle"
        }, 
        {
            "location": "/details/#evdi_selectable", 
            "text": "A typedef denoting a file descriptor you can watch to know when there are events being signalled from the kernel module.\nEach opened EVDI device handle has its own descriptor to watch.\nWhen the descriptor becomes ready to read from, the application should call  evdi_handle_events  to dispatch notifications to its handlers.", 
            "title": "evdi_selectable"
        }, 
        {
            "location": "/details/#evdi_device_status", 
            "text": "An enumerated type used while finding the DRM device node that is EVDI. Possible values are  AVAILABLE ,  UNRECOGNIZED  and  NOT_PRESENT .", 
            "title": "evdi_device_status"
        }, 
        {
            "location": "/details/#evdi_rect", 
            "text": "A simple structure used by the library to represent a rectangular area of a screen. Top left coordinates of the rectangle are  x1  and  y1 ,\nbottom right are  x2  and  y2 .", 
            "title": "evdi_rect"
        }, 
        {
            "location": "/details/#evdi_mode", 
            "text": "A structure used to describe a video mode that's set for a display. Contains details of resolution set ( width ,  height ), refresh rate ( refresh_rate ),\nand details of a pixel format used to encode color value ( bits_per_pixel  and  pixel_format  - which are forwarded from kernel's DRM).", 
            "title": "evdi_mode"
        }, 
        {
            "location": "/details/#evdi_buffer", 
            "text": "A structure holding details about a buffer.  typedef struct {\n    int id;\n    void* buffer;\n    int width;\n    int height;\n    int stride;\n\n    evdi_rect* rects;\n    int rect_count;\n} evdi_buffer;  Buffers have IDs, which can be arbitrarily chosen integer numbers - but typically a simple sequence of numbers starting\nfrom  0  is used in client applications. The pointer to the beginning of an already allocated memory block should be assigned\nto the  buffer  member of the structure. This memory will be filled by the kernel module when handling requests to grab pixels.  width ,  height  and  stride  are properties of the buffer - the first two indicate what the size of the frame is,\nand  stride  is a width stride - tells what is the increment in bytes between data for lines in memory.  Stride can be equal to width of a single line multiplied by the number of bytes necessary for encoding color value for one pixel (e.g. 4 for RGB32) if the data for lines are contigous in the memory,\nbut you can use larger value to indicate extra space/padding between them.  Last two structure members,  rects  and  rect_counts  are updated during grabbing pixels to inform about the number and coordinates of areas that are changed from the last update.", 
            "title": "evdi_buffer"
        }, 
        {
            "location": "/details/#evdi_event_context", 
            "text": "typedef struct {\n  void (*dpms_handler)(int dpms_mode, void* user_data);\n  void (*mode_changed_handler)(evdi_mode mode, void* user_data);\n  void (*update_ready_handler)(int buffer_to_be_updated, void* user_data);\n  void (*crtc_state_handler)(int state, void* user_data);\n  void* user_data;\n} evdi_event_context;  The  evdi_device_context  structure is used for holding pointers to handlers for all notifications that the application may receive from\nthe kernel module. The  user_data  member is a value that the library will use while dispatching the call back.\nSee  Events and handlers  for more information.", 
            "title": "evdi_event_context"
        }
    ]
}